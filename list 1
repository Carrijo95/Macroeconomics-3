### Tools and Techniques

## Section Linear Algebra

using LinearAlgebra, Statistics, Plots

gr(fmt=:png);

x_vals = [0 0 0 0; 2 -3 -4 2.5]
y_vals = [0 0 0 0 ; 4 3 -3.5 1.5]

Plots.plot(x_vals, y_vals, arrow = true, color = :blue,
     legend = :none, xlims = (-5, 5), ylims = (-5, 5),
     annotations = [(2.2, 4.4, "[2, 4]"),
                    (-3.3, 3.3, "[-3, 3]"),
                    (-4.4, -3.85, "[-4, -3.5]"),
                    (3, 2, "[2.5, 1.5]")],
     xticks = -5:1:5, yticks = -5:1:5,
     framestyle = :origin)


####

x = Vector(range(1,3))
y = ones(3)

# inner product
dot(x, y)
x ⋅ y

# norm
norm(x)
norm(y)

# fixed linear function, to generate a plane
f(x, y) = 0.2x + 0.1y

# lines to vectors
x_vec = [0 0; 3 3]
y_vec = [0 0; 4 -4]
z_vec = [0 0; f(3, 4) f(3, -4)]

# draw the plane
n = 20
grid = range(-5, 5, length = n)
z2 = [ f(grid[row], grid[col]) for row in 1:n, col in 1:n ]
wireframe(grid, grid, z2, fill = :blues, gridalpha =1 )
plot!(x_vec, y_vec, z_vec, color = [:blue :green], linewidth = 3, labels = "",
      colorbar = false)

## Matrixes

A = ones(3,3)

A*5

B = B + I

5*A.*B # element by element

A*B # matrix multiplication

A[1,1] = 4
A[2,3] = -1
A[1,2] = 0.5

y = [1,1,1]

x = inv(A)*y  # solution of a linear problem

A*x # cheking the results

A \ y # the same solution

# the least square solution
x_hat = inv(A'*A)*A'*y

evals, evecs = eigen(A)

evals
evecs

A * evecs[:,1],3)
evals[1].*evecs[:,1],3)

##

LLN and CLT

using InstantiateFromURL
# optionally add arguments to force installation: instantiate = true, precompile = true
github_project("QuantEcon/quantecon-notebooks-julia", version = "0.8.0")

using LinearAlgebra, Statistics
using Plots, Distributions, Random, Statistics
gr(fmt = :png, size = (900, 500))

function ksl(distribution, n = 100)
    title = nameof(typeof(distribution))
    observations = rand(distribution, n)
    sample_means = cumsum(observations) ./ (1:n)
    μ = mean(distribution)
    plot(repeat((1:n)', 2),
         [zeros(1, n); observations'], label = "", color = :grey, alpha = 0.5)
    plot!(1:n, observations, color = :grey, markershape = :circle,
          alpha = 0.5, label = "", linewidth = 0)
    if !isnan(μ)
        hline!([μ], color = :black, linewidth = 1.5, linestyle = :dash, grid = false,
               label = ["Mean"])
    end
    plot!(1:n, sample_means, linewidth = 3, alpha = 0.6, color = :green,
          label = "Sample mean")
    return plot!(title = title)
end

ksl(Normal())

distributions = [TDist(10), Beta(2, 2), Gamma(5, 2), Poisson(4), LogNormal(0.5),
                 Exponential(1)]

plot(ksl.(sample(distributions,4, replace = false))..., layout =  (4,1), legend = false)


plot(1:100, rand(Poisson(4), 100), color =:red,markershape = :circle)
hline!([mean(rand(Poisson(4),100))], color = :black)

using KernelDensity

using StatsPlots
function simulation1(distribution, n = 250, k = 10_000)
    σ = std(distribution)
    y = rand(distribution, n, k)
    y .-= mean(distribution)
    y = mean(y, dims = 1)
    y = √n * vec(y)
    density(y, label = "Empirical Distribution")
    return plot!(Normal(0, σ), linestyle = :dash, color = :black,
                 label = "Normal(0.00, $(σ^2))")
end

simulation1(Poisson(1))
simulation1(Beta(2,2))
simulation1(Exponential(0.5))

# Delta method

function delta_method(distribution,n, k, g, g_dev)
    μ, σ =  mean(distribution), std(distribution)
    y = rand(distribution, n, k)
    y = mean(y, dims=1)
    y = vec(y)
    if g_dev(μ) != 0
        error_obs = sqrt(n) .*(g.(y) - g.(μ))
        denstity(error_obs,label ="Empirical Distribution")
        return plot!(Normal(0, g_dev(μ) .* σ), linestyle:dash, lable = "Asymptotic",
        color = :black)
    else println("μ = 0, delta method is not satisfied")
    end
end

f(x) = x.^2
f_derivate(x) = 2x

typeof(f())
typeof(f_derivate())

function f(x)
    return x^2
end

function f_dev(x)
    return 2x
end


delta_method(Normal(1.0,1.0), 100, 10000, f, f_dev)
